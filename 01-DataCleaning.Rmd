# Data cleaning - Vultures

All tracking devices come with errors, and each track must be checked visual and cleaned of outliers before analysis.
 
This page shows this process for each animal within the project. It has been automated so that we always have access to a stardardised and cleaned locations database. 
```{r}
library(atlastools)
library(ctmm)
library(move2)


# Order based on timestamp
tmp <- dat[order(dat$timestamp),]

tmp <- tmp[, c("name", "taxon_canonical_name", "country")]
tmp <- tmp[duplicated(tmp)==F,]

tmp$name <- as.character(tmp$name)
tmp_vulture <- tmp[tmp$taxon_canonical_name %in% c("Cathartes aura", "Cathartes melambrotus", "Coragyps atratus", "Sarcoramphus papa"),]
tmp_mammal <- tmp[!(tmp$taxon_canonical_name %in% c("Cathartes aura", "Cathartes melambrotus", "Coragyps atratus", "Sarcoramphus papa")),]


# Update the stupid ecuador birds
tmp_vulture$name[tmp_vulture$name=="Quil"] <- "X2.Quil"
tmp_vulture$name[tmp_vulture$name=="Guayas"] <- "X1.Guayas"
tmp_vulture$name[tmp_vulture$name=="Pigio"] <- "X3.Pigio"
tmp_vulture$name[tmp_vulture$name=="Guasmo"] <- "X4.Guasmo"
tmp_vulture$name[tmp_vulture$name=="Daule"] <- "X6.Daule"
tmp_vulture$name[tmp_vulture$name=="Ceibo"] <- "X7.Ceibo"


clean_vulture <- list()
clean_mammal <- list()

i <- 1
```

Animals are cleaned in the order in which they occur in the database. 

### Vultures

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v1, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),
     ylab="Minimum speed (m/s)",
     xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v2, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v3, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v4, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v5, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v6, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v7, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v8, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v9, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v10, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v11, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v12, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v13, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v14, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v15, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

points(OUT$distance[OUT$speed>50]/1000, OUT$speed[OUT$speed>50], pch=19,col=rgb(1,0,0))
```

The point in red has been removed!

Check it has gone:

```{r}
# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

m2 <- clean_vulture[[i]]
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v16, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v17, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v18, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v19, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v20, }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v21}
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v22}
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v23 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v24 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 

plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v25 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")


points(OUT$distance[OUT$speed>50]/1000, OUT$speed[OUT$speed>50], pch=19,col=rgb(1,0,0))
```

The point in red has been removed!

```{r}

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

m2 <- clean_vulture[[i]]
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v26 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v27 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v28 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v29 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

#nrow(mov_dat[[tmp_vulture$name[i]]])
#nrow(m_df)
# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v30}
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

**NOTE** It is not possible to make the error plot as it takes to long due to the 1 second data window. I have checked it offline and it is good. 


```{r v31 }
#Kingkong

#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
##plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object

# Sub sample the track to hourly
tmp <- clean_vulture[[i]]
tmp$ID <- substr(tmp$timestamp, 1,13)
tmp <- tmp[duplicated(tmp$ID)==F,]

m_df <- as.data.frame(tmp)
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v32 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v33 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v34 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v35 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v36 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v37 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v38 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v39 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v40 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v41 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v42 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v43 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v44 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v45 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v46 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v47 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v48 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v49 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v50 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v51 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v52 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v53 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v54 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v55 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<15,]

# Check the outlier is gone [Only if required]

m2 <- clean_vulture[[i]]
dat_lines <- m2 %>%
  mt_track_lines()
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%
# Add the shapefiles
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   #color = dat_lines$colours,
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>%
  addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v56 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v57 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v58 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v59 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v60 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v61 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v62 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v63 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v64 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v65 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v66 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v67 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v68 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")


# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v69 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v70 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v71 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v72 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v73 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v74 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v75 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v76}
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v77 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v78 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v79 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v80 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v81 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE)
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v82 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```



### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v83 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v84 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("Satellite","OS", "Simple")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v85 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v86 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v87 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v88 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v89 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v90 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v91 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v92 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

### `r paste(tmp_vulture$name[i], "-" ,tmp_vulture$taxon_canonical_name[i])`

First observation: `r first(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Last observation:  `r last(dat$timestamp[dat$name==tmp_vulture$name[i]])`

Active for: `r paste(round(as.numeric((last(dat$timestamp[dat$name==tmp_vulture$name[i]]) - first(dat$timestamp[dat$name==tmp_vulture$name[i]]))),1), "days")`

```{r v93 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```

```{r v94 }
#################################################################################
m1 <- mov_dat[[tmp_vulture$name[i]]]

# Most issues arise through dodgy fixes -> most easily observed in the heigh above elipsoid
# Filter these out straight away
m1 <- m1[!(m1$height_above_ellipsoid>5000 & is.na(m1$height_above_ellipsoid)==F) ,]

# Make a dataframe
m_df <- as.data.frame(m1)

# Height above elipsoid check
# summary(m_df$gps_satellite_count)
# summary(m_df$height_above_ellipsoid)
# plot(m_df$location_long, m_df$location_lat)
# test <- m_df[m_df$height_above_ellipsoid>5000 & is.na(m_df$height_above_ellipsoid)==F ,]
# points(test$location_long, test$location_lat, col="red")

# move2
m2 = mt_as_move2(m1, track_id_columna = tmp_vulturename[i])

# Convert to track
dat_lines <- m2 %>% 
  mt_track_lines()

m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# Add the shapefiles 
m %>% addPolylines(data = dat_lines,
                   # Colour by individual
                   color = "#FF10F0",
                   # The line properties
                   weight = 1,#opacity = 0.6,
                   # hover label
                   label = dat_lines$local_identifier) %>%
    addCircleMarkers(lng=m_df$location_long[1],
                   lat=m_df$location_lat[1], 
                   color="#03F",
                   popup="start") %>% 
    addCircleMarkers(lng=m_df$location_long[nrow(m_df)],
                   lat=m_df$location_lat[nrow(m_df)], 
                   color="red",
                   popup="end") %>% 
  # Add a legend
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite")) %>% 
  addScaleBar(position = "topleft")

# Finding outliers
# There are several ways to remove them but I'm going to use atlastools and ctmm framework
# METHOD 1 - GEOFENCE
#plot(m_df$location_long, m_df$location_lat, asp = 1, type = "o")
m_df <- atl_filter_bounds(m_df, x = "location_long", 
                              y = "location_lat", x_range = c(-88, -60), 
                              y_range = c(-20, 20),remove_inside = FALSE)

# Method 2 -
# Create a telemtry object
tel = as.telemetry(m_df)
#Import: we can add the estimation of error for Shakira from above code 
# However, the error is negligible, but as an example is useful
uere(tel)-> UERE

# Check outliers
par(mfrow = c(1, 2))
outlie(tel)-> OUT
#plot(OUT, units = FALSE) 
plot(OUT$distance/1000, OUT$speed, pch=19,col=rgb(0,0,0,0.2),      ylab="Minimum speed (m/s)",      xlab="Median deviation (km)")

# SPECIES SPECIFIC THRESHOLD
abline(h=50, lty=2, col="red")

# Delete extreme values 
clean_vulture[[i]] <- m2[OUT$speed<50,]

# Check the outlier is gone [Only if required]

# m2 <- clean_vulture[[i]]
# dat_lines <- m2 %>% 
#   mt_track_lines()
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$CartoDB.PositronNoLabels, group="Simple") %>%
#   addProviderTiles(providers$Esri.WorldImagery       , group="Satellite") %>%
#   addProviderTiles(providers$OpenStreetMap.Mapnik    , group="OS") #%>%     
# # Add the shapefiles 
# m %>% addPolylines(data = dat_lines,
#                    # Colour by individual
#                    #color = dat_lines$colours,
#                    # The line properties
#                    weight = 1,#opacity = 0.6,
#                    # hover label
#                    label = dat_lines$local_identifier) %>%
#   # Add a legend
#   addLayersControl(
#     baseGroups = c("OS", "Simple", "Satellite")) %>% 
#   addScaleBar(position = "topleft")

# Recreate the telemtry object
m_df <- as.data.frame(clean_vulture[[i]])
tel <- as.telemetry(m_df)

# Check range-residency (i.e home range)
svf = variogram(tel, res = 1)
level <- c(0.5, 0.95) # 50% and 95% CIs
xlim <- c(0,24 %#% "hours") # 0-12 hour window
plot(svf, fraction = 0.65, level = level, main = tmp_vulture$name[i]) 

# # Variogram fitting
# # In ctmm.guess put "save to GUESS" or change "interactive = FALSE"
# # Estimation of actual error is add in "error = TRUE"
# GUESS <- ctmm.guess(Shakc, CTMM = ctmm(error = FALSE),variogram = NULL, name ="GUESS", interactive = TRUE)
# vadj = ctmm.select(Shakc, CTMM = GUESS, verbose = TRUE, core = 0, MSPE = "position", level = 1)
# ?ctmm.select
# # Summary
# summary(vadj)
# ouf = vadj[[1]]
# summary(ouf)
# # Home range 
# Hr = akde(Spaw, CTMM = ouf, weights = TRUE, debias = TRUE)
# # Plot the 95% Utilization Distribution 
# plot(Shakc, UD = Hr, level.UD = 0.95, main = "Shakira")
# summary(Hr, level.UD = 0.95)

i <- i + 1
```


### Number of vultures processed
 
We have `r length(unique(tmp_vulture$name))` vulture names.

We have processed `r i-1` vultures.

### Upload clean data

```{r vulture_upload}
dir.create("tmp")
# Create.csv

vulture_stack <- mt_stack(clean_vulture)
tmp_csv <- as.data.frame(vulture_stack)
tmp_csv$geometry <- NULL
write.csv(tmp_csv, "tmp/vulture_clean.csv", row.names=F)
saveRDS(vulture_stack, "tmp/vulture_stack.RDS")
as_id("https://drive.google.com/file/d/15xrhSRqUwSBWiesEYDdE5-4Hui4mdSJg/view?usp=drive_link")
# Create .RDS

# OC's googledrive
drive_update(media = 'tmp/vulture_clean.csv',file=as_id("1aNOCLrhzqH1CJF_CTPfZEfQQVMYJmQ-l"))
drive_update(media = 'tmp/vulture_stack.RDS',file=as_id("1tHtZYF56I9Ch40Rurtmdul2CvqRnH504"))


# Chris'googledrive
#drive_update(media = 'tmp/vulture_clean.csv',file=as_id("15xrhSRqUwSBWiesEYDdE5-4Hui4mdSJg"))
#drive_update(media = 'tmp/vulture_stack.RDS',file=as_id("1s-C7sgp7sOZ7KkoCXqaAeASEiYIAPmo3"))
```



